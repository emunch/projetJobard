<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html><head><title>OpenGL Mathematics : Problématiques</title><meta http-equiv="Content-Language" content="fr, be, ca, lu, ch" /><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=iso-8859-1" /><meta name="copyright" content="&#65533; 2005 C-Truc Creation" /><link href="../common/style.css" rel="stylesheet" media="screen, print, embossed" type="text/css" /></head><body><div class="title">OpenGL Mathematics</div><table><tr><td class="menu"><div class="menu1"><a href="../en/news.html">English</a></div><br /><div class="menu1">Menu</div><div class="menu2"><a class="menu" href="./news.html">News</a></div><div class="menu2"><a class="menu" href="./download.html">Téléchargements</a></div><div class="menu2"><a class="menu" href="./changelog.html">Changelog</a></div><div class="menu2"><a class="menu" href="./issue.html">Problématiques</a></div><div class="menu2"><a class="menu" href="./bug.html">Bugs</a></div><div class="menu2"><a class="menu" href="../html/index.html">Documentation</a></div><div class="menu2"><a class="menu" href="./link.html">Liens</a></div><br /><div class="menu2"><a href="http://validator.w3.org/check/referer"><img class="menu-img" src="http://www.w3.org/Icons/valid-xhtml11" alt="Valid XHTML 1.1!" /></a></div><div class="menu2"><a href="http://www.opengl.org"><img class="menu-img" src="../common/opengl.jpg" alt="OpenGL" /></a></div><div class="menu2"><a href="http://www.sourceforge.net"><img class="menu-img" src="../common/sourceforge.gif" alt="SourceForge" /></a></div><div class="menu2"><a href="http://www.g-truc.net"><img class="menu-img" src="../common/g-truc.jpg" alt="G-Truc" /></a></div></td><td class="page"><div><div class="title2">Problématiques</div><br /><div class="issue-title">10) De nombreux outils très utils manquent dans GLSL, est il possible d'en ajouter ?<br /></div><div><div class="issue-content">DISCUTION: IL est vrai que GLSL n'est pas une bibliothèque mathématique ultime. Par exemple au niveau des opérations sur les matrices, les spécifications sont très limités. Ainsi, il n'y a pas de fonctions pour obtenir le déterminant, l'inverse ou encore la transposée d'une matrice. De plus, il y a peu de types vecteurs et matrices différents et pas de quaternions.</div><div class="issue-content">PROPOSAL: Pourquoi ne pas proposer tous ces manques sous forme d'extensions ? Elle sera développé à partir des convensions de GLSL ce qui pourrait par exemple donnée l'extension GLM_GTX_quaternion, elle définirait le type __quatGT et la fonction conjugateGT.</div><div class="issue-content">PROPOSAL: Les extensions seraient disponibles depuis un fichier distinct de celui dédié au core de la bibliothèque, le fichier glmext.h.</div><div class="issue-content">PROPOSAL: Il serait intéressant de proposer des implémentations des extensions de GLM directement en GLSL afin de favoriser la portabilité. Voir avec opportunisme, de proposer des extensions à l'ARB.</div><br /><div class="issue-content">
            STATUE : Particiellement résolue, 2005-03-21</div></div><br /><div class="issue-title">9) Faut il inclure GLM dans un espace de nom ?<br /></div><div><div class="issue-content">DISCUTION: L'utilisation d'un espace de nom permet de prévenir les problèmes de collisions de noms avec d'autres bibliothèques comme la STL. GLSL dispose du mot clé réservé 'namespace' mais ne le définit pas. OpenGL utilise une technique C pour la gestion des espaces de noms avec le préfixe 'gl'. Quel nom faut t'il donner à cette espace de nom ? 'gl', 'glsl', 'glm' or 'sl'. Qu'elle est la meilleur solution ? Les espaces de noms à la manière du C ou du C++ ?</div><div class="issue-content">DISCUTION: Le bug 3 indique que 'not' est un mot clé C++. L'utilisation des espaces de noms C résoud alors ce bug mais GLSL a été construit à partir du C mais dans une logique orienté vers le C++.</div><br /><div class="issue-content">
            STATUE : Non resolue, 2005-02-18</div></div><br /><div class="issue-title">8) Faut il tenir compte de l'API OpenGL ?<br /></div><div><div class="issue-content">DISCUTION: L'intéraction avec OpenGL n'est pas le but en soit de GLM. Pourtant, il ne faut pas perdre de vue que GLM doit pouvoir être utilisable facilement avec OpenGL et certaines possibilités pourrait être bienvenu. Par exemple, l'utilisation du type vec3 avec la fonction Vertex3fv pourrait simplifier et optimiser le programme. Enfin, d'un point de vue sémentique, le vec3 est plus corrérant et plus robuste qu'une adresse sur un potentiel tableau de trois float.</div><div class="issue-content">RESOLUTION: S'il est possible de facilité l'interopérabilité de GLM et d'OpenGL alors ce travail est recommandé si la sémentique est correcte. GLM doit également rester indépendante d'OpenGL.</div><br /><div class="issue-content">
            STATUE : Résolue, 2005-03-04</div></div><br /><div class="issue-title">7) Comment prendre en compte les mots clés réservés ?<br /></div><div><div class="issue-content">DISCUTION: Les spécifications de GLSL précise la liste de mots clés reservés mais non implémenté. Leur utilisation doit retourner une erreur. Certains existent déjà dans C++.</div><div class="issue-content">RESOLUTION: GLM ne peut qu'autoriser les mots clés réservés du C++. Les autres doivent être indéfinit pour que le compilateur retourne une erreur.</div><br /><div class="issue-content">
            STATUE : Particiellement résolue, 2005-01-26</div></div><br /><div class="issue-title">6) Comment gérer les qualificatifs de GLSL ?<br /></div><div><div class="issue-content">DISCUTION: GLSL définit six types de qualificatifs de variables: const, varying, uniform, attrib, in, out, inout.</div><div class="issue-content">RESOLUTION: Les variables 'const' ne sont utilisables qu'en local dans un shader. Elles sont disponibles pour les vertex et fragment shaders. Les 'const' de GLSL sont équivalent au 'static const' du langage C++, c'est à dire que la variable n'existe qu'à l'intérieur d'une unité de compilation.(un .o sous GCC)</div><div class="issue-content">RESOLUTION: Les variables varying propose une interface de communication entre le vertex et le fragment shader. Les variables uniform et attrib sont un moyen de communication entre le programme C/C++ et les shaders, les varying n'ont donc aucune utilité dans le programme C++. Ce qualificatif n'est donc pas autorisé</div><div class="issue-content">SUGGESTION: Certains programmers utilisent déjà les qualificatifs in, out et inout pour leurs valeurs sémantiques. Ils les définissent comme des '#define' vide.</div><div class="issue-content">DISCUTION: Il semble difficile de concerver la même syntaxe que GLSL pour les variables uniform et attrib bien que cette notion semble intéressante. Pourquoi ne pas simplement conservé uniquement leurs valeurs sémentiques ?</div><br /><div class="issue-content">
            STATUE : Particiellement résolue, 2005-03-04</div></div><br /><div class="issue-title">5) Faut il tenir compte des variables intégrés ?<br /></div><div><div class="issue-content">SUGGESTION: Tous les variables intégrées correspondent aux variables d'états d'OpenGL. Elles sont donc toutes accéssibles à partir de l'API d'OpenGL.</div><br /><div class="issue-content">
            STATUE : Résolue, 2005-01-13</div></div><br /><div class="issue-title">4) Faut il tenir compte des types sampler* ?<br /></div><div><div class="issue-content">DISCUTION: Les types sampler* proviennent de l'extension GL_ARB_multitexture. Leurs valeurs correspondent à une unité de textures.</div><div class="issue-content">SUGGESTION: Un type sampler offrirai une valeur sémentique additionnelle.</div><div class="issue-content">SUGGESTION: Non, ce n'est pas l'objectif de GLM.</div><br /><div class="issue-content">
            STATUE : Résolue, 2005-03-05</div></div><br /><div class="issue-title">3) Comment gérer les accès spécifiques aux composantes des types *vec* ?<br /></div><div><div class="issue-content">DISCUTION: GLSL permet un accès à plusieurs composantes en même temps. De plus, GLSL laisse la possibilité à l'utilisateur d'ordonner les compossantes comme il le souhait. Pour implémenter, une telle possibilité il faudrait intégrer 4² * 3 * 2 = 96 fonctions pour le type vec4, par exemple. 4 : Le nombre de composantes. 3: Le nombre de types d'accès. 2: un accès en lecture seul et un accès en écriture.</div><div class="issue-content">RESOLUTION: Une méthode a été trouvé basé sur les reférences. Cependant, elle implique l'utilisation d'un grand nombre de fonctions mais elle permet de parfaitement satisfaire les spécifications de GLSL. Cette fonctionnalité sera intégré dans les prochaines versions.</div><br /><div class="issue-content">
            STATUE : Fermée, 2005-01-22</div></div><br /><div class="issue-title">2) Comment accéder aux composantes des types *vec* ?<br /></div><div><div class="issue-content">DISCUTION: GLSL permet un accès à une composante avec plusieurs noms différents, d'où la notion de composante. Par exemple : La première composante d'un vec3 est accécible avec .x, .r ou .s.</div><div class="issue-content">PROPOSAL: Une possibilité serait de créer trois fonctions pour chaque composante.</div><div class="issue-content">PROPOSAL: Une autre serait d'utiliser le mot clé "union".</div><div class="issue-content">RESOLUTION: La première solution permet de contenir les valeurs des compossantes dans un tableau privé des classes cependant mais dans ce cas il faut utiliser l'opérateur [] surchargé pour accéder aux valeurs et/ou des fonctions par composante ce qui n'est pas conforme aux spécifications de GLSL. La seconde respect les règles de GLSL mais les composantes sont publiques. Ce n'est pas un réel problème dans ce cas donc cette deusième solution est validée.</div><br /><div class="issue-content">
            STATUE : Fermée, 2005-01-15</div></div><br /><div class="issue-title">1) Comment considérer les fonctions dédiés aux fragments shaders et la fonction ftransform ?<br /></div><div><div class="issue-content">RESOLUTION: Les spécifications de GLSL précisent que les 'fragment processing functions' ne sont dispoble que pour les fragment shaders et que la fonction ftransform n'est disponible que pour les vertex shaders. Le programme C/C++ doit être considéré comment un troisème type de programmes donc ces fonctions ne sont pas disponibles.</div><br /><div class="issue-content">
            STATUE : Fermée, 2005-01-12</div></div><br /></div></td></tr></table><div class="title3">Copyright © 2005-2006 <a href="http://www.g-truc.net">G-Truc Creation</a></div><div class="title3">OpenGL est une marque déposée par Silicon Graphics Inc.</div><div class="title3">Les spécifications de GLSL sont protégés par copyright et leurs contenus est la propriété de 3Dlabs</div></body></html>